fn main() {
    demo1();
    demo2();
    demo3();
}

// let和let mut声明变量的区别
fn demo1() {
    // 1.默认let声明为不可变量
    let x = 5;
    // 2.使用mut声明变量为可变变量
    let mut y = 10;
    println!("demo1第一次输出x:{},y:{}", x, y);
    // 3.y变量是可变的，可以重新赋值为20,但是重新复制类型必须保持一致
    y = 20;
    // x为不可变量，赋值会直接提示错误
    // x = 10；
    println!("demo1第二次输出x:{},y:{}", x, y);
    // 4.用let对y重新赋值，可以改变类型
    // 看到一个新声明的变量可以覆盖掉旧的同名变量,称为"隐藏(shadow)"
    // 和go语音里面恰恰相反，同一代码块内不可重复声明同一变量，但可以重复使用
    let y = "rust";
    println!("demo1第三次输出y:{}", y);
}

// let和const声明变量区别
fn demo2() {
    // 约定俗成全字母大写下划线分隔命名，且必须标明类型
    const RUST_CONST: i32 = 1;
    let y = 2;
    println!("demo2第一次输出x:{},y:{}", RUST_CONST, y);
    // 5.在同一个代码块内量只能赋值一次,下面语句报错
    //const RUST_CONST: i32 = 11;
}

// 数据类型溢出
fn demo3() {
    /*
    假设你有一个u8类型的变量，它可以存储从0到255的数字。当
你尝试将该变量修改为某个超出范围的值（比如256）时，就会发
生整数溢出。Rust在这一行为中拥有某些有趣的规则。如果你在调
试（debug）模式下进行编译，那么Rust就会在程序中包含整数溢
出的运行时检测代码，并在整数溢出发生时触发程序的panic。
Rust使用术语panic来描述程序因为错误而退出的情形；我们会在
第9章的“不可恢复错误与panic!”一节中讨论更多有关panic的内
容。
如果你在编译时使用了带有--release标记的发布（release）
模式，那么Rust就不会包含那些可能会触发panic的检查代码。作
为替代，Rust会在溢出发生时执行二进制补码环绕。简而言之，任
何超出类型最大值的数值都会被“环绕”为类型最小值。以u8为
例，256会变为0，257会变为1，以此类推。虽然程序不会发生
panic，但变量中实际存储的值也许会让你大吃一惊。那些依赖于
整数溢出时环绕行为的代码应该被视作错误代码。假如你确实希望
显式地进行环绕行为，那么你可以使用标准库中的类型Wrapping。
    */
    // u8范围：0~255
    let x: u8 = 10;
    println!("demo3第一次输出x:{}", x);
    let x:u8 = 256;
    println!("demo3第二次输出x:{}", x);
}


