### 一、rust变量与可变性
1. Rust中的变量默认是不可变的。目的是为了能够让你安全且方便地写出复杂、甚至是并行的代码。当一个变量是不可变的时，一旦它被绑定到某个值上面，这个值
就再也无法被改变。
   比如：下面运行是会报错的，应为x=5已经是默认不可变的，不可以二次赋值给x
```go
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
2. Rust的编译器能够保证那些声明为不可变的值一定不会发生改变。这也意味着你无须在阅读和编写代码时追踪一个变量会如何变化，从而使代码逻辑更加易于理解
   和推导。不过，可变性也同样非常有用,你可以通过在声明的变量名称前添加mut关键字来使其可变。除了使变量的值可变，mut还会向阅读代码的人暗示其他代码
   可能会改变这个变量的值。
```go
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```
正是因为使用了mut定义了变量，使得我们可以合法地将x绑定的值从5修改为6了。在某些情况下，相较于不可变变量而言，可变变量会让代码变得更加
易于编写。除了避免出现bug，设计一个变量的可变性还需要考量许多因素。例如当你在使用某些重型数据结构时，适当地使用可变性去修改一个实例，可能比赋值和
重新返回一个新分配的实例要更有效率；而当数据结构较为轻量的时候，采用更偏向函数式的风格，通过创建新变量来进行赋值，可能会使代码更加易于理解。在类似这
样的情形下，为了可读性而损失少许的性能也许是值得的。

### 二、rust变量与常量不同
与变量相对的另一个编程概念：常量（constant）。就像不可变变量一样，绑定到常量上的值无法被其他代码修改，但不可变量有隐藏性质，而常量没有，但常量和变量之间
还是存在着一些细微的差别的。首先，我们不能用mut关键字来修饰一个常量。常量不仅是默认不可变的，它还总是不可变的。其次，你需要使用const关键字而不是
let关键字来声明一个常量。在声明的同时，你必须显式地标注值的类型。再次，常量可以被声明在任何作用域中，甚至包括全局作用域。这在一个值需要被不同部分的代码共同
引用时十分有用。 最后，你只能将常量绑定到一个常量表达式上，而无法将一个函数的返回值，或其他需要在运行时计算的值绑定到常量上。在Rust程序中，我们约
定俗成地使用以下画线分隔的全大写字母来命名一个常量，并在数值中插入下画线来提高可读性。
```go
    const MAX_POINTS: u32 = 100_000;
```
常量在整个程序运行的过程中都在自己声明的作用域内有效，因此可以作为不同代码之间共享值，例如一个游戏中所有玩家可以获取的最高分数，或者光速之类的东西。

### 三、rust中不可变量与隐藏
    先看下面代码：
```go
fn main() {
    let x = 5;
    let x = x + 1;
    let x = x * 2;
    println!("The value of x is: {}", x);
}
```
这段程序首先将x绑定到值5上。随后它又通过重复let x = 语句隐藏了第一个x变量，并将第一个x变量值加上1的运算结果绑定到新的变
量x上，这时x的值是6。第三个let语句同样隐藏了第二个x变量，并将第二个x变量值乘以2的结果12绑定到第三个x变量上。
隐藏机制不同于将一个变量声明为mut，因为如果不是在使用let关键字的情况下重新为这个变量赋值，则会导致编译错误。通过使用let，我们可以对这个值执行一
系列的变换操作，并允许这个变量在操作完成后保持自己的不可变性。隐藏机制与mut的另一个区别在于：由于重复使用let关键字会创建出新的变量，更重要的是我们
在复用变量名称的同时改变它的类型。注意是可以改变类型的。