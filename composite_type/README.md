## rust之复合类型

### 一、内置复合类型—元祖(tuple)
1. 元组是可以将其他不同类型的多个值组合进一个复合类型中。元组还拥有一个固定的长度：你无法在声明结束后增加或减少其中的元素数量。通常使用逗号分隔后放
   置到一对圆括号中创建一个元组。元组每个位置的值都有一个类型，这些类型不需要是相同的。
```
fn main() {
    demo1();
    demo2();
}

// 元组声明和元组元素获取
fn demo1() {
    // 1.每个元组元素都可以单独声明具体的数据类型否则就是默认类型
    let tup: (i32, f32, u8) = (32, 3.2, 8);
    println!("demo1输出1：tup={:?}",tup);
    // 使用".下标"来解析元组对应位置值，从0下标开始
    let x = tup.0;
    let y = tup.1;
    let z = tup.2;
    println!("demo1输出2：x={},y={},z={}", x, y, z);
    // 使用模式匹配来解析元组
    let (x, y, z) = tup;
    println!("demo1输出3：x={},y={},z={}", x, y, z);
}
```
由于一个元组也被视作一个单独的复合元素，所以这里的变量tup被绑定到了整个元组上。为了从元这段程序首先创建了一个元组，并将其绑定到了变量tup上。随后，
let关键字的右侧使用了一个模式将tup拆分为3个不同的部分：x、y和z，这个操作也被称为解构（destructuring）。

### 二、内置复合类型-数组(array)
1.数组是存储一个或多个相同类型元素的一个内置复合类型。Rust中的数组拥有固定的长度，一旦声明就再也不能随意更改大小，这与go语言中的数组类似。如果实际
业务需求不能确定元素大小则可以用动态数组(vector)类型。

```go
// 数组声明和元素获取
fn demo2() {
    // 1.省略数组类型写法，默认为i32,长度为后面赋值的实际个数数量
    let a = [0, 1, 2, 3];
    println!("demo2输出1：a={:?}", a);
    // 2.指明数组元组类型为i8,长度为3
    let b: [i8; 3] = [0, 1, 2];
    println!("demo2输出2：b={:?}", b);
    // 3.声明数组类型为可变，因为默认是不可变
    let mut c = [1, 2, 3];
    println!("demo2输出3：c={:?}", c);
    // 4.通过0下标值由原来1修改为11
    c[0] = 11;
    println!("demo2输出4：c={:?}", c);
    // 5.指定元素值全为"d"及长度为5,";"分隔
    let d1 = ["d"; 5];
    println!("demo2输出5：d1={:?}",d1);
    // 等价于下面写法
    let d2 = ["d", "d", "d", "d", "d"];
    println!("demo2输出5：d2={:?}",d2);
    // 注意数组下标不能超过数组实际大小否则报panic错误，如下面注释
    // 运行时报报错：index out of bounds: the length is 5 but the index is 10
    // let element = d[10];
}
```

deme1和demo2的代码输出如下：
```go
demo1输出1：tup=(32, 3.2, 8)
demo1输出2：x=32,y=3.2,z=8
demo1输出3：x=32,y=3.2,z=8
demo2输出1：a=[0, 1, 2, 3]
demo2输出2：b=[0, 1, 2]
demo2输出3：c=[1, 2, 3]
demo2输出4：c=[11, 2, 3]
demo2输出5：d1=["d", "d", "d", "d", "d"]
demo2输出5：d2=["d", "d", "d", "d", "d"]
```